package com.lagradost

import android.util.Base64
import android.util.Log
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.USER_AGENT
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.network.CloudflareKiller
import com.lagradost.cloudstream3.network.WebViewResolver
import com.lagradost.cloudstream3.utils.ExtractorApi
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.ExtractorLinkType
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.utils.newExtractorLink
import org.json.JSONObject
import java.security.MessageDigest
import javax.crypto.Cipher
import javax.crypto.spec.IvParameterSpec
import javax.crypto.spec.SecretKeySpec

/**
 * Extractor for playhydrax.com / abysscdn.com video player.
 *
 * The video URLs are dynamically generated by JavaScript (core.bundle.js).
 * This extractor uses WebView to execute the JS and capture the real video URLs.
 *
 * URL flow:
 * 1. Page contains base64-encoded encrypted data
 * 2. JS decrypts and transforms URLs to GCS (storage.googleapis.com) format
 * 3. GCS URLs are time-limited and require proper referer
 *
 * Fallback decryption process (if WebView fails):
 * 1. Extract base64-encoded JSON data from page source
 * 2. Decode and parse JSON to get slug, md5_id, user_id, and encrypted media
 * 3. Derive key from MD5("user_id:slug:md5_id") as UTF-8 string (32 bytes)
 * 4. Use AES-256-CTR to decrypt media field
 * 5. Parse decrypted JSON for video sources
 */
open class Playhydrax : ExtractorApi() {
    override var name = "Playhydrax"
    override var mainUrl = "https://playhydrax.com"
    override val requiresReferer = true

    companion object {
        private const val TAG = "Playhydrax"
        private const val VERSION = "v2.0-2026-01-19"  // Version identifier for debugging
        // Regex to capture GCS URLs from page/requests
        private val GCS_URL_REGEX = Regex("""https?://storage\.googleapis\.com/mediastorage/[^"'\s\\<>]+\.mp4[^"'\s\\<>]*""")

        // Pre-compiled regex patterns for video extraction
        private val BASE64_DATA_REGEX = Regex("""(?:const|var)\s+datas\s*=\s*["']([A-Za-z0-9+/=]+)["']""")
        private val GCS_GENERIC_REGEX = Regex("""https?://storage\.googleapis\.com/[^"'\s\\]+""")
        private val GCS_MP4_REGEX = Regex("""https?://storage\.googleapis\.com/mediastorage/[^'"#\s]+\.mp4""")
        private val SSSRR_REGEX = Regex("""https?://[a-z0-9]+\.sssrr\.org/[^'"#\s]+""")
        private val M3U8_REGEX = Regex("""https?://[^'"#\s]+\.m3u8[^'"#\s]*""")
        private val QUALITY_NUMBER_REGEX = Regex("[^0-9]")
    }

    private val cfInterceptor = CloudflareKiller()

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        Log.d(TAG, "[$VERSION] Extracting from: $url")

        val actualReferer = referer ?: "https://tube.perverzija.com/"

        // Priority 1: Try WebView-based extraction to capture GCS URLs from JS execution
        val webViewSuccess = tryWebViewExtraction(url, actualReferer, callback)
        if (webViewSuccess) {
            Log.d(TAG, "WebView extraction successful")
            return
        }

        // Priority 2: Try direct page fetch and decryption
        val pageHtml = fetchPage(url, actualReferer) ?: return

        // Extract and decrypt media data
        val mediaData = extractAndDecryptMedia(pageHtml)
        if (mediaData != null) {
            parseMediaSources(mediaData, actualReferer, callback)
            return
        }

        // Fallback to regex extraction if decryption fails
        Log.d(TAG, "Decryption failed, trying regex fallback")
        tryRegexExtraction(pageHtml, actualReferer, callback)
    }

    /**
     * Use WebView to load the page and capture GCS URLs.
     *
     * The player (JWPlayer) generates GCS URLs dynamically via JavaScript.
     * We try to intercept these URLs when the player makes requests.
     *
     * GCS URL pattern: storage.googleapis.com/mediastorage/{timestamp}/{hash}/{size}.mp4
     */
    private suspend fun tryWebViewExtraction(
        url: String,
        referer: String,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        return try {
            Log.d(TAG, "Starting WebView extraction for: $url")

            // Use WebViewResolver to intercept GCS URLs
            // The player will request these URLs when it starts loading
            val response = app.get(
                url,
                referer = referer,
                headers = mapOf(
                    "Accept" to "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
                    "User-Agent" to USER_AGENT
                ),
                interceptor = WebViewResolver(
                    // Primary pattern: GCS mediastorage URLs
                    Regex("""storage\.googleapis\.com/mediastorage/\d+/[a-z0-9]+/\d+\.mp4"""),
                    // Additional patterns to capture
                    additionalUrls = listOf(
                        // Any GCS URL with .mp4
                        Regex("""storage\.googleapis\.com/[^"'\s]+\.mp4"""),
                        // sssrr.org sora endpoint (might redirect to GCS)
                        Regex("""[a-z0-9]+\.sssrr\.org/sora/\d+/[A-Za-z0-9+/=]+""")
                    ),
                    // Longer timeout to wait for player initialization
                    timeout = 45000L
                )
            )

            val gcsUrls = mutableSetOf<String>()

            // Check if we intercepted a GCS URL directly
            val responseUrl = response.url
            Log.d(TAG, "WebView response URL: $responseUrl")

            if (responseUrl.contains("storage.googleapis.com") && responseUrl.contains(".mp4")) {
                val cleanUrl = responseUrl.substringBefore("#")
                gcsUrls.add(cleanUrl)
                Log.d(TAG, "Intercepted GCS URL: $cleanUrl")
            }

            // Also check response body for embedded GCS URLs
            val pageContent = response.text
            GCS_URL_REGEX.findAll(pageContent).forEach { match ->
                val rawUrl = match.value
                val cleanUrl = rawUrl
                    .substringBefore("#")
                    .substringBefore("\"")
                    .substringBefore("'")
                    .substringBefore("\\")
                    .substringBefore("<")
                if (cleanUrl.contains("storage.googleapis.com") && cleanUrl.endsWith(".mp4")) {
                    gcsUrls.add(cleanUrl)
                    Log.d(TAG, "Found GCS URL in page: $cleanUrl")
                }
            }

            if (gcsUrls.isNotEmpty()) {
                Log.d(TAG, "WebView extraction found ${gcsUrls.size} GCS URLs")
                gcsUrls.forEach { gcsUrl ->
                    val quality = getQualityFromUrl(gcsUrl)
                    addVideoLink(gcsUrl, quality, callback)
                }
                true
            } else {
                Log.d(TAG, "No GCS URLs found via WebView")
                false
            }
        } catch (e: Exception) {
            Log.e(TAG, "WebView extraction failed: ${e.message}")
            false
        }
    }

    private suspend fun fetchPage(url: String, referer: String): String? {
        return try {
            app.get(
                url,
                referer = referer,
                headers = mapOf(
                    "Accept" to "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
                    "User-Agent" to USER_AGENT
                ),
                interceptor = cfInterceptor,
                timeout = 30L
            ).text
        } catch (e: Exception) {
            Log.e(TAG, "Failed to fetch page: ${e.message}")
            null
        }
    }

    /**
     * Extract base64 data blob and decrypt media field.
     */
    private fun extractAndDecryptMedia(html: String): JSONObject? {
        // Pattern: const datas = "BASE64_STRING" or var datas = "BASE64_STRING"
        val match = BASE64_DATA_REGEX.find(html) ?: return null

        return try {
            val base64Data = match.groupValues[1]
            // Decode base64 using ISO-8859-1 to preserve all byte values (0-255)
            // The JSON contains a "media" field with binary encrypted data that would be
            // corrupted by UTF-8 decoding (high bytes aren't valid UTF-8 sequences)
            val decoded = String(Base64.decode(base64Data, Base64.DEFAULT), Charsets.ISO_8859_1)
            val json = JSONObject(decoded)

            val slug = json.optString("slug", "")
            val md5Id = json.optLong("md5_id", 0)
            val userId = json.optLong("user_id", 0)
            // Get media string - JSONObject decodes Unicode escapes like \u001f to actual characters
            val media = json.optString("media", "")

            if (slug.isEmpty() || md5Id == 0L || userId == 0L || media.isEmpty()) {
                Log.e(TAG, "Missing required fields in data blob")
                return null
            }

            Log.d(TAG, "Found data: slug=$slug, md5_id=$md5Id, user_id=$userId, mediaLen=${media.length}")

            // Decrypt the media field
            val decryptedMedia = decryptMedia(userId, slug, md5Id, media)
            if (decryptedMedia != null) {
                Log.d(TAG, "Decrypted media: ${decryptedMedia.take(200)}...")
                JSONObject(decryptedMedia)
            } else {
                null
            }
        } catch (e: Exception) {
            Log.e(TAG, "Failed to extract/decrypt media: ${e.message}")
            e.printStackTrace()
            null
        }
    }

    /**
     * Decrypt the encrypted media field using AES-256-CTR.
     *
     * Key derivation:
     * - Key string: "user_id:slug:md5_id"
     * - MD5 hash the key string to get 32-char hex string
     * - Use MD5 hex string as UTF-8 bytes for 256-bit key (32 bytes)
     * - Counter/IV: first 16 bytes of the key
     */
    private fun decryptMedia(userId: Long, slug: String, md5Id: Long, encryptedMedia: String): String? {
        return try {
            // Step 1: Create key string
            val keyString = "$userId:$slug:$md5Id"
            Log.d(TAG, "Key string: $keyString")

            // Step 2: MD5 hash of key string (returns 32-char hex string)
            val md5Hash = md5Hex(keyString)
            Log.d(TAG, "MD5 hash: $md5Hash")

            // Step 3: Key is MD5 hex string as UTF-8 bytes (32 bytes for AES-256)
            val keyBytes = md5Hash.toByteArray(Charsets.UTF_8)

            // Step 4: Counter/IV is first 16 bytes of key
            val counter = keyBytes.copyOfRange(0, 16)

            // Step 5: Convert encrypted media string to bytes (ISO-8859-1 preserves byte values)
            val encryptedBytes = encryptedMedia.toByteArray(Charsets.ISO_8859_1)

            // Step 6: AES-CTR decryption
            val cipher = Cipher.getInstance("AES/CTR/NoPadding")
            val secretKey = SecretKeySpec(keyBytes, "AES")
            val ivSpec = IvParameterSpec(counter)
            cipher.init(Cipher.DECRYPT_MODE, secretKey, ivSpec)

            val decryptedBytes = cipher.doFinal(encryptedBytes)
            String(decryptedBytes, Charsets.UTF_8)
        } catch (e: Exception) {
            Log.e(TAG, "Decryption failed: ${e.message}")
            e.printStackTrace()
            null
        }
    }

    /**
     * Compute MD5 hash and return as lowercase hex string.
     */
    private fun md5Hex(input: String): String {
        val md = MessageDigest.getInstance("MD5")
        val digest = md.digest(input.toByteArray(Charsets.UTF_8))
        return digest.joinToString("") { "%02x".format(it) }
    }

    /**
     * Parse decrypted media JSON and extract video sources.
     * Priority: GCS URLs > /sora/ endpoint > HLS > other sources
     */
    private suspend fun parseMediaSources(
        mediaData: JSONObject,
        referer: String,
        callback: (ExtractorLink) -> Unit
    ) {
        try {
            // Log full media data for debugging
            Log.d(TAG, "Full media data keys: ${mediaData.keys().asSequence().toList()}")

            var foundWorkingSource = false

            // Priority 1: Look for Google Cloud Storage URLs anywhere in the JSON
            val mediaString = mediaData.toString()
            val seenGcsUrls = mutableSetOf<String>()
            GCS_GENERIC_REGEX.findAll(mediaString).forEach { match ->
                val fullUrl = match.value
                val quality = getQualityFromUrl(fullUrl)
                val baseUrl = fullUrl.substringBefore("#")
                if (baseUrl.endsWith(".mp4") && baseUrl !in seenGcsUrls) {
                    seenGcsUrls.add(baseUrl)
                    Log.d(TAG, "Found GCS URL: $baseUrl (quality: ${quality}p)")
                    addVideoLink(baseUrl, quality, callback)
                    foundWorkingSource = true
                }
            }

            // Priority 1b: Try "sources" array (common JWPlayer format)
            val sources = mediaData.optJSONArray("sources")
            if (sources != null) {
                for (i in 0 until sources.length()) {
                    val source = sources.optJSONObject(i) ?: continue
                    val file = source.optString("file", "")
                    val label = source.optString("label", "")
                    if (file.isNotBlank() && file.contains("storage.googleapis.com")) {
                        val baseUrl = file.substringBefore("#")
                        if (baseUrl !in seenGcsUrls) {
                            seenGcsUrls.add(baseUrl)
                            val quality = if (label.isNotBlank()) getQualityFromLabel(label) else getQualityFromUrl(file)
                            Log.d(TAG, "Found source: $baseUrl (label: $label, quality: ${quality}p)")
                            addVideoLink(baseUrl, quality, callback)
                            foundWorkingSource = true
                        }
                    }
                }
            }

            // Priority 2: Try /sora/ endpoint - this is the main video delivery mechanism
            // The endpoint URL: https://{sub}.sssrr.org/sora/{size}/{token}
            val mp4 = mediaData.optJSONObject("mp4")
            if (mp4 != null && !foundWorkingSource) {
                Log.d(TAG, "MP4 data keys: ${mp4.keys().asSequence().toList()}")

                // Get domains list
                val domains = mp4.optJSONArray("domains")
                val domainList = mutableListOf<String>()
                if (domains != null) {
                    for (i in 0 until domains.length()) {
                        domainList.add(domains.optString(i, ""))
                    }
                }
                Log.d(TAG, "Domains: $domainList")

                // Get source metadata
                val mp4Sources = mp4.optJSONArray("sources")
                if (mp4Sources != null) {
                    Log.d(TAG, "Found ${mp4Sources.length()} sources in mp4.sources")

                    for (i in 0 until mp4Sources.length()) {
                        val source = mp4Sources.optJSONObject(i) ?: continue
                        val sub = source.optString("sub", "")
                        val size = source.optLong("size", 0)
                        val label = source.optString("label", "")
                        val resId = source.optInt("res_id", 0)
                        val quality = resIdToQuality(resId)

                        Log.d(TAG, "Source: sub=$sub, size=$size, label=$label, res_id=$resId")

                        if (sub.isNotBlank() && size > 0) {
                            // Try to get video via /sora/ endpoint
                            val soraSuccess = trySoraEndpoint(sub, size, quality, referer, callback)
                            if (soraSuccess) {
                                foundWorkingSource = true
                            }
                        }
                    }
                }

                // Fallback: Try .fd URLs from fristDatas
                if (!foundWorkingSource) {
                    val fristDatas = mp4.optJSONArray("fristDatas")
                    if (fristDatas != null) {
                        for (i in 0 until fristDatas.length()) {
                            val source = fristDatas.optJSONObject(i) ?: continue
                            val url = source.optString("url", "")
                            val resId = source.optInt("res_id", 0)
                            val quality = resIdToQuality(resId)

                            if (url.isBlank()) continue

                            // Direct MP4 URLs
                            if (url.endsWith(".mp4")) {
                                Log.d(TAG, "Found direct MP4 source: $url (${quality}p)")
                                addVideoLink(url, quality, callback)
                                foundWorkingSource = true
                            }
                        }
                    }
                }

                // Check for backup URLs
                val backup = mp4.optJSONArray("backup")
                if (backup != null) {
                    for (i in 0 until backup.length()) {
                        val url = backup.optString(i, "")
                        if (url.isNotBlank() && url.endsWith(".mp4")) {
                            Log.d(TAG, "Found backup MP4: $url")
                            addVideoLink(url, Qualities.Unknown.value, callback)
                            foundWorkingSource = true
                        }
                    }
                }
            }

            // Priority 3: Try HLS sources
            val hls = mediaData.optJSONObject("hls")
            if (hls != null && !foundWorkingSource) {
                val hlsSources = hls.optJSONArray("sources")
                if (hlsSources != null) {
                    for (i in 0 until hlsSources.length()) {
                        val source = hlsSources.getJSONObject(i)
                        val url = source.optString("url", "")
                        if (url.isNotBlank() && url.contains(".m3u8")) {
                            Log.d(TAG, "Found HLS source: $url")
                            callback.invoke(
                                newExtractorLink(
                                    name,
                                    name,
                                    url,
                                    type = ExtractorLinkType.M3U8
                                ) {
                                    this.referer = "$mainUrl/"
                                    this.headers = videoHeaders()
                                }
                            )
                            foundWorkingSource = true
                        }
                    }
                }
            }

            if (!foundWorkingSource) {
                Log.w(TAG, "No working sources found in decrypted media")
            }
        } catch (e: Exception) {
            Log.e(TAG, "Failed to parse media sources: ${e.message}")
        }
    }

    /**
     * Try the /sora/ endpoint to get the actual video URL.
     * The endpoint may redirect to a GCS URL or return the video directly.
     *
     * URL pattern: https://{sub}.sssrr.org/sora/{size}/{token}
     *
     * Note: The /sora/ endpoint requires a token that is generated by JS.
     * Without the correct token, this endpoint will fail.
     * This method tries various approaches to get a working video URL.
     */
    private suspend fun trySoraEndpoint(
        sub: String,
        size: Long,
        quality: Int,
        referer: String,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        // The /sora/ endpoint requires a signed token that's generated by JS
        // We can't generate this token without reverse-engineering the JS
        // For now, log what we have and skip this approach
        Log.d(TAG, "Sora endpoint: sub=$sub, size=$size (token required)")

        // Try direct sssrr.org URL patterns that might work
        val directUrls = listOf(
            // Pattern 1: /c/ endpoint (chunk/download)
            "https://$sub.sssrr.org/c/$size.mp4",
            // Pattern 2: /v/ endpoint (video)
            "https://$sub.sssrr.org/v/$size",
            // Pattern 3: Direct file
            "https://$sub.sssrr.org/$size.mp4"
        )

        for (testUrl in directUrls) {
            try {
                Log.d(TAG, "Testing URL: $testUrl")
                val response = app.get(
                    testUrl,
                    referer = "$mainUrl/",
                    headers = mapOf(
                        "Accept" to "video/webm,video/ogg,video/*;q=0.9,*/*;q=0.5",
                        "Origin" to mainUrl,
                        "User-Agent" to USER_AGENT
                    ),
                    interceptor = cfInterceptor,
                    timeout = 15L,
                    allowRedirects = false
                )

                // Check for redirect to GCS
                val location = response.headers["Location"] ?: response.headers["location"]
                if (location != null && location.contains("storage.googleapis.com")) {
                    Log.d(TAG, "Got GCS redirect from $testUrl: $location")
                    addVideoLink(location, quality, callback)
                    return true
                }

                // Check if this is video content
                val contentType = response.headers["Content-Type"] ?: ""
                if (contentType.startsWith("video/") || response.code == 200) {
                    // Verify it's actually video by checking content-length
                    val contentLength = response.headers["Content-Length"]?.toLongOrNull() ?: 0
                    if (contentLength > 1000000) { // > 1MB likely video
                        Log.d(TAG, "Found direct video at: $testUrl")
                        addVideoLink(testUrl, quality, callback)
                        return true
                    }
                }

                // Check response body for GCS URLs
                if (response.code == 200) {
                    val body = response.text
                    GCS_URL_REGEX.find(body)?.let { match ->
                        val gcsUrl = match.value.substringBefore("#").substringBefore("\"")
                        Log.d(TAG, "Found GCS URL in response: $gcsUrl")
                        addVideoLink(gcsUrl, quality, callback)
                        return true
                    }
                }
            } catch (e: Exception) {
                Log.d(TAG, "URL $testUrl failed: ${e.message}")
            }
        }

        return false
    }

    /**
     * Convert resolution ID to quality value.
     */
    private fun resIdToQuality(resId: Int): Int {
        return when (resId) {
            1 -> Qualities.P240.value
            2 -> Qualities.P360.value
            3 -> Qualities.P480.value
            4 -> Qualities.P720.value
            5 -> Qualities.P1080.value
            6 -> Qualities.P1440.value
            7 -> Qualities.P2160.value
            else -> Qualities.Unknown.value
        }
    }

    /**
     * Fallback: Try to find video URLs directly in page source.
     */
    private suspend fun tryRegexExtraction(
        html: String,
        referer: String,
        callback: (ExtractorLink) -> Unit
    ) {
        val seenUrls = mutableSetOf<String>()

        // Pattern 1: sssrr.org CDN URLs
        SSSRR_REGEX.findAll(html).forEach { match ->
            val url = match.value.substringBefore("#").substringBefore("\"")
            if (url !in seenUrls && url.contains("/c/")) {
                seenUrls.add(url)
                addVideoLink(url, getQualityFromUrl(url), callback)
            }
        }

        // Pattern 2: Google Cloud Storage URLs
        GCS_MP4_REGEX.findAll(html).forEach { match ->
            val url = match.value.substringBefore("#")
            if (url !in seenUrls) {
                seenUrls.add(url)
                addVideoLink(url, getQualityFromUrl(url), callback)
            }
        }

        // Pattern 3: M3U8 URLs
        M3U8_REGEX.find(html)?.let { match ->
            val url = match.value.substringBefore("#")
            if (url !in seenUrls) {
                seenUrls.add(url)
                callback.invoke(
                    newExtractorLink(
                        name,
                        name,
                        url,
                        type = ExtractorLinkType.M3U8
                    ) {
                        this.referer = "$mainUrl/"
                        this.headers = videoHeaders()
                    }
                )
            }
        }
    }

    private suspend fun addVideoLink(
        url: String,
        quality: Int,
        callback: (ExtractorLink) -> Unit
    ) {
        val cleanUrl = url.substringBefore("#")

        // Skip non-playable URLs (.fd files are encrypted references, not video)
        if (cleanUrl.endsWith(".fd")) {
            Log.d(TAG, "Skipping non-playable .fd URL: $cleanUrl")
            return
        }

        callback.invoke(
            newExtractorLink(
                name,
                "$name ${quality}p",
                cleanUrl,
                type = ExtractorLinkType.VIDEO
            ) {
                this.quality = quality
                this.referer = "$mainUrl/"
                this.headers = videoHeaders()
            }
        )
    }

    private fun getQualityFromUrl(url: String): Int {
        return when {
            url.contains("2160") || url.contains("4k", ignoreCase = true) -> Qualities.P2160.value
            url.contains("1440") -> Qualities.P1440.value
            url.contains("1080") -> Qualities.P1080.value
            url.contains("720") -> Qualities.P720.value
            url.contains("480") -> Qualities.P480.value
            url.contains("360") -> Qualities.P360.value
            url.contains(".5.") -> Qualities.P1080.value  // res_id 5 = 1080p
            url.contains(".4.") -> Qualities.P720.value   // res_id 4 = 720p
            url.contains(".2.") -> Qualities.P360.value   // res_id 2 = 360p
            else -> Qualities.P720.value
        }
    }

    private fun getQualityFromLabel(label: String): Int {
        val qualityNum = label.replace(QUALITY_NUMBER_REGEX, "").toIntOrNull() ?: 720
        return when (qualityNum) {
            2160 -> Qualities.P2160.value
            1440 -> Qualities.P1440.value
            1080 -> Qualities.P1080.value
            720 -> Qualities.P720.value
            480 -> Qualities.P480.value
            360 -> Qualities.P360.value
            240 -> Qualities.P240.value
            else -> Qualities.Unknown.value
        }
    }

    /**
     * Headers for video playback.
     * The CDN requires playhydrax.com as referer, not the original site.
     */
    private fun videoHeaders() = mapOf(
        "Accept" to "*/*",
        "Referer" to "$mainUrl/",
        "Origin" to mainUrl,
        "User-Agent" to USER_AGENT
    )
}
